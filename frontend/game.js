const gameContainer = document.getElementById('game');
let board = [];
let gameOver = false;
let gameStarted = false;
let startTime = 0;
let timer = null;
let difficulty = 'easy';
let bestTimes = {
  easy: localStorage.getItem('bestTime_easy') || null,
  medium: localStorage.getItem('bestTime_medium') || null,
  hard: localStorage.getItem('bestTime_hard') || null
};

// –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —É—Ä–æ–≤–Ω–µ–π —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
const difficulties = {
  easy: { size: 5, mineCount: 5 },
  medium: { size: 8, mineCount: 12 },
  hard: { size: 10, mineCount: 20 }
};

// –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
let gridW; // —à–∏—Ä–∏–Ω–∞ –ø–æ–ª—è
let gridH; // –≤—ã—Å–æ—Ç–∞ –ø–æ–ª—è
let numMines; // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–∏–Ω
let mines; // –º–∞—Å—Å–∏–≤ –º–∏–Ω (1 - –º–∏–Ω–∞ –µ—Å—Ç—å, 0 - –º–∏–Ω—ã –Ω–µ—Ç)
let flags; // –º–∞—Å—Å–∏–≤ —Ñ–ª–∞–≥–æ–≤ (true - —Ñ–ª–∞–≥ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω)
let revealed; // –º–∞—Å—Å–∏–≤ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –∫–ª–µ—Ç–æ–∫ (true - –∫–ª–µ—Ç–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∞)

// –î–æ–±–∞–≤–ª—è–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –¥–æ–ª–≥–æ–≥–æ –Ω–∞–∂–∞—Ç–∏—è
let longPressTimer;
let isLongPress = false;

// Initialize Telegram WebApp
const tg = window.Telegram.WebApp;
tg.expand();

// –ù–∞—á–∞–ª—å–Ω—ã–π —ç–∫—Ä–∞–Ω —Å –≤—ã–±–æ—Ä–æ–º —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
function showDifficultySelection() {
  gameContainer.innerHTML = '';
  const title = document.createElement('h2');
  title.textContent = '–í—ã–±–µ—Ä–∏—Ç–µ —Å–ª–æ–∂–Ω–æ—Å—Ç—å:';
  gameContainer.appendChild(title);

  const difficultyButtons = document.createElement('div');
  difficultyButtons.className = 'difficulty-buttons';
  
  ['easy', 'medium', 'hard'].forEach(diff => {
    const button = document.createElement('button');
    button.textContent = diff === 'easy' ? '–õ–µ–≥–∫–∏–π' : diff === 'medium' ? '–°—Ä–µ–¥–Ω–∏–π' : '–°–ª–æ–∂–Ω—ã–π';
    button.className = 'difficulty-button';
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ª—É—á—à–µ–µ –≤—Ä–µ–º—è, –µ—Å–ª–∏ –æ–Ω–æ –µ—Å—Ç—å
    if (bestTimes[diff]) {
      button.textContent += ` (${formatTime(parseInt(bestTimes[diff]))})`;
    }
    
    button.addEventListener('click', () => {
      difficulty = diff;
      initGame();
    });
    
    difficultyButtons.appendChild(button);
  });
  
  gameContainer.appendChild(difficultyButtons);
}

// –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –≤ –º–º:—Å—Å
function formatTime(ms) {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
}

// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–∞–π–º–µ—Ä–∞
function updateTimer() {
  if (!gameStarted || gameOver) return;
  
  const currentTime = Date.now() - startTime;
  document.getElementById('timer').textContent = formatTime(currentTime);
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã—Ö–æ–¥–∞ –∑–∞ –ø—Ä–µ–¥–µ–ª—ã –ø–æ–ª—è
function outBounds(x, y) {
  return x < 0 || y < 0 || x >= gridW || y >= gridH;
}

// –ü–æ–¥—Å—á–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –º–∏–Ω –≤–æ–∫—Ä—É–≥ –∫–ª–µ—Ç–∫–∏
function calcNear(x, y) {
  if (outBounds(x, y)) return 0;
  let count = 0;
  for (let offsetX = -1; offsetX <= 1; offsetX++) {
    for (let offsetY = -1; offsetY <= 1; offsetY++) {
      if (outBounds(x + offsetX, y + offsetY)) continue;
      count += mines[x + offsetX][y + offsetY];
    }
  }
  return count;
}

// –û—Ç–∫—Ä—ã—Ç–∏–µ –∫–ª–µ—Ç–∫–∏
function reveal(x, y) {
  if (outBounds(x, y)) return;
  if (revealed[x][y]) return;
  if (flags[x][y]) return;

  revealed[x][y] = true;
  updateCellAppearance(x, y);

  if (calcNear(x, y) !== 0) return;

  // –ï—Å–ª–∏ –≤–æ–∫—Ä—É–≥ –Ω–µ—Ç –º–∏–Ω, –æ—Ç–∫—Ä—ã–≤–∞–µ–º —Å–æ—Å–µ–¥–Ω–∏–µ –∫–ª–µ—Ç–∫–∏
  reveal(x - 1, y - 1);
  reveal(x - 1, y + 1);
  reveal(x + 1, y - 1);
  reveal(x + 1, y + 1);
  reveal(x - 1, y);
  reveal(x + 1, y);
  reveal(x, y - 1);
  reveal(x, y + 1);
}

// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–Ω–µ—à–Ω–µ–≥–æ –≤–∏–¥–∞ –∫–ª–µ—Ç–∫–∏
function updateCellAppearance(x, y) {
  const index = x * gridH + y;
  const cell = board[index];
  
  if (revealed[x][y]) {
    cell.classList.add('revealed');
    const nearCount = calcNear(x, y);
    if (nearCount > 0) {
      cell.textContent = nearCount;
      cell.classList.add(`cell-${nearCount}`);
    }
  }
}

// –†–∞–∑–º–µ—â–µ–Ω–∏–µ –º–∏–Ω –Ω–∞ –ø–æ–ª–µ
function placeMines(excludeX, excludeY) {
  let placed = 0;
  while (placed < numMines) {
    const x = Math.floor(Math.random() * gridW);
    const y = Math.floor(Math.random() * gridH);
    
    // –ù–µ —Å—Ç–∞–≤–∏–º –º–∏–Ω—É –≤ –∫–ª–µ—Ç–∫—É –ø–µ—Ä–≤–æ–≥–æ –∫–ª–∏–∫–∞ –∏ –≤–æ–∫—Ä—É–≥ –Ω–µ—ë
    if (Math.abs(x - excludeX) <= 1 && Math.abs(y - excludeY) <= 1) continue;
    
    if (mines[x][y] === 0) {
      mines[x][y] = 1;
      placed++;
    }
  }
}

// –û—á–∏—Å—Ç–∫–∞ –ø–æ–ª—è –æ—Ç –º–∏–Ω
function clearMines() {
  for (let x = 0; x < gridW; x++) {
    for (let y = 0; y < gridH; y++) {
      mines[x][y] = 0;
    }
  }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ –ø–æ –∫–ª–µ—Ç–∫–µ
function handleCellClick(cell) {
  if (gameOver) return;
  
  const index = parseInt(cell.dataset.index);
  const x = Math.floor(index / gridH);
  const y = index % gridH;
  
  if (flags[x][y]) return;
  
  if (!gameStarted) {
    gameStarted = true;
    startTime = Date.now();
    if (timer) clearInterval(timer);
    timer = setInterval(updateTimer, 1000);
    
    // –ü–µ—Ä–≤—ã–π –∫–ª–∏–∫ –Ω–µ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–∞ –º–∏–Ω—É
    do {
      clearMines();
      placeMines(x, y);
    } while (calcNear(x, y) !== 0);
  }
  
  if (mines[x][y] === 1) {
    gameOver = true;
    revealAll();
    clearInterval(timer);
    tg.showAlert('üí• –ë—É–º! –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞.');
  } else {
    reveal(x, y);
    checkWin();
  }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Ñ–ª–∞–≥–∞
function toggleFlag(cell) {
  if (gameOver || !cell) return;
  
  const index = parseInt(cell.dataset.index);
  const x = Math.floor(index / gridH);
  const y = index % gridH;
  
  if (revealed[x][y]) return;
  
  if (!gameStarted) {
    gameStarted = true;
    startTime = Date.now();
    if (timer) clearInterval(timer);
    timer = setInterval(updateTimer, 1000);
  }
  
  flags[x][y] = !flags[x][y];
  cell.classList.toggle('flagged');
  updateFlagCounter();
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
function initGame() {
  const size = difficulties[difficulty].size;
  numMines = difficulties[difficulty].mineCount;
  gridW = size;
  gridH = size;
  
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–∞—Å—Å–∏–≤–æ–≤
  mines = Array(gridW).fill().map(() => Array(gridH).fill(0));
  flags = Array(gridW).fill().map(() => Array(gridH).fill(false));
  revealed = Array(gridW).fill().map(() => Array(gridH).fill(false));
  
  gameContainer.innerHTML = '';
  board = [];
  gameOver = false;
  gameStarted = false;
  
  // –°–æ–∑–¥–∞–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
  createGameInterface();
  
  // –°–æ–∑–¥–∞–µ–º –∏–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ
  createGameBoard();
}

// –°–æ–∑–¥–∞–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –∏–≥—Ä—ã
function createGameInterface() {
  const gameHeader = document.createElement('div');
  gameHeader.className = 'game-header';
  
  const flagCounter = document.createElement('div');
  flagCounter.id = 'flag-counter';
  flagCounter.textContent = numMines;
  
  const timerDisplay = document.createElement('div');
  timerDisplay.id = 'timer';
  timerDisplay.textContent = '00:00';
  
  const restartButton = document.createElement('button');
  restartButton.id = 'restart-button';
  restartButton.textContent = 'üîÑ';
  restartButton.addEventListener('click', () => {
    clearInterval(timer);
    initGame();
  });
  
  const backButton = document.createElement('button');
  backButton.id = 'back-button';
  backButton.textContent = '‚¨ÖÔ∏è';
  backButton.addEventListener('click', () => {
    clearInterval(timer);
    showDifficultySelection();
  });
  
  gameHeader.appendChild(flagCounter);
  gameHeader.appendChild(timerDisplay);
  gameHeader.appendChild(restartButton);
  gameHeader.appendChild(backButton);
  
  gameContainer.appendChild(gameHeader);
}

// –°–æ–∑–¥–∞–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
function createGameBoard() {
  const boardElement = document.createElement('div');
  boardElement.id = 'board';
  boardElement.style.gridTemplateColumns = `repeat(${gridW}, 40px)`;
  
  for (let x = 0; x < gridW; x++) {
    for (let y = 0; y < gridH; y++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');
      cell.dataset.index = x * gridH + y;
      
      cell.addEventListener('click', () => handleCellClick(cell));
      cell.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        toggleFlag(cell);
      });
      
      // –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤
      let touchTimeout;
      cell.addEventListener('touchstart', () => {
        touchTimeout = setTimeout(() => {
          toggleFlag(cell);
        }, 500);
      });
      
      cell.addEventListener('touchend', (e) => {
        if (touchTimeout) {
          clearTimeout(touchTimeout);
          handleCellClick(cell);
        }
      });
      
      cell.addEventListener('touchmove', () => {
        if (touchTimeout) {
          clearTimeout(touchTimeout);
        }
      });
      
      boardElement.appendChild(cell);
      board.push(cell);
    }
  }
  
  gameContainer.appendChild(boardElement);
}

// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—á–µ—Ç—á–∏–∫–∞ —Ñ–ª–∞–∂–∫–æ–≤
function updateFlagCounter() {
  let flagCount = 0;
  for (let x = 0; x < gridW; x++) {
    for (let y = 0; y < gridH; y++) {
      if (flags[x][y]) flagCount++;
    }
  }
  document.getElementById('flag-counter').textContent = numMines - flagCount;
}

// –û—Ç–∫—Ä—ã—Ç—å –≤—Å–µ —è—á–µ–π–∫–∏ –ø—Ä–∏ –æ–∫–æ–Ω—á–∞–Ω–∏–∏ –∏–≥—Ä—ã
function revealAll() {
  for (let x = 0; x < gridW; x++) {
    for (let y = 0; y < gridH; y++) {
      const index = x * gridH + y;
      const cell = board[index];
      
      if (mines[x][y] === 1) {
        cell.classList.add('mine');
        if (flags[x][y]) {
          cell.classList.add('correct-flag');
        }
      } else if (flags[x][y]) {
        cell.classList.add('wrong-flag');
      }
      
      if (!revealed[x][y] && !flags[x][y]) {
        revealed[x][y] = true;
        updateCellAppearance(x, y);
      }
    }
  }
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–±–µ–¥—ã
function checkWin() {
  let unrevealedSafeCells = 0;
  for (let x = 0; x < gridW; x++) {
    for (let y = 0; y < gridH; y++) {
      if (!revealed[x][y] && mines[x][y] === 0) {
        unrevealedSafeCells++;
      }
    }
  }
  
  if (unrevealedSafeCells === 0) {
    gameOver = true;
    clearInterval(timer);
    
    // –ü–æ–º–µ—á–∞–µ–º –≤—Å–µ –º–∏–Ω—ã —Ñ–ª–∞–∂–∫–∞–º–∏
    for (let x = 0; x < gridW; x++) {
      for (let y = 0; y < gridH; y++) {
        if (mines[x][y] === 1 && !flags[x][y]) {
          flags[x][y] = true;
          board[x * gridH + y].classList.add('flagged');
        }
      }
    }
    
    const gameTime = Date.now() - startTime;
    let newRecord = false;
    
    if (!bestTimes[difficulty] || gameTime < parseInt(bestTimes[difficulty])) {
      bestTimes[difficulty] = gameTime.toString();
      localStorage.setItem(`bestTime_${difficulty}`, gameTime);
      newRecord = true;
    }
    
    const message = newRecord 
      ? `üéâ –ü–æ–±–µ–¥–∞! –ù–æ–≤—ã–π —Ä–µ–∫–æ—Ä–¥: ${formatTime(gameTime)}!` 
      : `üéâ –ü–æ–±–µ–¥–∞! –í–∞—à–µ –≤—Ä–µ–º—è: ${formatTime(gameTime)}. –†–µ–∫–æ—Ä–¥: ${formatTime(parseInt(bestTimes[difficulty]))}`;
    
    tg.showAlert(message);
  }
}

// –ó–∞–ø—É—Å–∫–∞–µ–º –∏–≥—Ä—É —Å —ç–∫—Ä–∞–Ω–∞ –≤—ã–±–æ—Ä–∞ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
showDifficultySelection();